# Day 1 â€“ The `Enum` Standard Library
#
# Run with `mix run day_one/05_enum_library.exs`
#
# `Enum` provides a rich set of functions for working with *enumerables* â€“ data
# structures that implement the `Enumerable` protocol (lists, maps, ranges,
# streamsâ€¦). Below are five illustrative examples, capped off by a more
# realistic data-analysis snippet.

IO.puts("\nðŸ“Œ Example 1 â€“ Enum.map/2 to transform a list")

IO.inspect(Enum.map([1, 2, 3], &(&1 * 10)))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IO.puts("\nðŸ“Œ Example 2 â€“ Enum.filter/2 to keep even numbers")

IO.inspect(Enum.filter(1..10, &(rem(&1, 2) == 0)))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IO.puts("\nðŸ“Œ Example 3 â€“ Enum.reduce/3 to compute a product")

product = Enum.reduce(1..5, 1, &*/2)
IO.inspect(product, label: "factorial-ish")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IO.puts("\nðŸ“Œ Example 4 â€“ Enum.group_by/3 to categorize structs")

defmodule Pet do
  defstruct [:name, :type]
end

pets = [
  %Pet{name: "Milo",  type: :dog},
  %Pet{name: "Luna",  type: :cat},
  %Pet{name: "Otto",  type: :dog}
]

IO.inspect(Enum.group_by(pets, & &1.type))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IO.puts("\nðŸ“Œ Example 5 â€“ Enum.into/2 to convert a range into a map")

IO.inspect(Enum.into(1..3, %{}, fn n -> {n, n * n} end))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
IO.puts("\nðŸ“Œ Example 6 â€“ Real-world: aggregating orders")

orders = [
  %{id: 1, customer: "Ada",    total_cents: 4_500, status: :shipped},
  %{id: 2, customer: "Grace",  total_cents: 1_500, status: :processing},
  %{id: 3, customer: "Ada",    total_cents: 3_000, status: :shipped},
  %{id: 4, customer: "Linus",  total_cents: 2_000, status: :cancelled}
]

shipment_totals =
  orders
  |> Enum.filter(& &1.status == :shipped)
  |> Enum.group_by(& &1.customer)
  |> Enum.map(fn {customer, ords} ->
    total = Enum.reduce(ords, 0, fn o, acc -> acc + o.total_cents end)
    {customer, total / 100}
  end)
  |> Enum.into(%{})

IO.inspect(shipment_totals, label: "Shipped totals by customer ($)")
